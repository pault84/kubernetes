/*
Copyright 2015 The Kubernetes Authors All rights reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// ************************************************************
// DO NOT EDIT.
// THIS FILE IS AUTO-GENERATED BY codecgen.
// ************************************************************

package testgroup

import (
	"errors"
	"fmt"
	codec1978 "github.com/ugorji/go/codec"
	pkg2_api "k8s.io/kubernetes/pkg/api"
	pkg1_unversioned "k8s.io/kubernetes/pkg/api/unversioned"
	pkg3_types "k8s.io/kubernetes/pkg/types"
	"reflect"
	"runtime"
	time "time"
)

const (
	// ----- content types ----
	codecSelferC_UTF81234 = 1
	codecSelferC_RAW1234  = 0
	// ----- value types used ----
	codecSelferValueTypeArray1234 = 10
	codecSelferValueTypeMap1234   = 9
	// ----- containerStateValues ----
	codecSelfer_containerMapKey1234    = 2
	codecSelfer_containerMapValue1234  = 3
	codecSelfer_containerMapEnd1234    = 4
	codecSelfer_containerArrayElem1234 = 6
	codecSelfer_containerArrayEnd1234  = 7
)

var (
	codecSelferBitsize1234                         = uint8(reflect.TypeOf(uint(0)).Bits())
	codecSelferOnlyMapOrArrayEncodeToStructErr1234 = errors.New(`only encoded map or array can be decoded into a struct`)
)

type codecSelfer1234 struct{}

func init() {
	if codec1978.GenVersion != 5 {
		_, file, _, _ := runtime.Caller(0)
		err := fmt.Errorf("codecgen version mismatch: current: %v, need %v. Re-generate file: %v",
			5, codec1978.GenVersion, file)
		panic(err)
	}
	if false { // reference the types, but skip this branch at build/run time
		var v0 pkg2_api.ObjectMeta
		var v1 pkg1_unversioned.TypeMeta
		var v2 pkg3_types.UID
		var v3 time.Time
		_, _, _, _ = v0, v1, v2, v3
	}
}

func (x *TestType) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer1234
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yym1 := z.EncBinary()
		_ = yym1
		if false {
		} else if z.HasExtensions() && z.EncExt(x) {
		} else {
			yysep2 := !z.EncBinary()
			yy2arr2 := z.EncBasicHandle().StructToArray
			var yyq2 [4]bool
			_, _, _ = yysep2, yyq2, yy2arr2
			const yyr2 bool = false
			yyq2[0] = true
			yyq2[1] = true
			yyq2[2] = x.Kind != ""
			yyq2[3] = x.APIVersion != ""
			var yynn2 int
			if yyr2 || yy2arr2 {
				r.EncodeArrayStart(4)
			} else {
				yynn2 = 0
				for _, b := range yyq2 {
					if b {
						yynn2++
					}
				}
				r.EncodeMapStart(yynn2)
				yynn2 = 0
			}
			if yyr2 || yy2arr2 {
				z.EncSendContainerState(codecSelfer_containerArrayElem1234)
				if yyq2[0] {
					yy4 := &x.ObjectMeta
					yym5 := z.EncBinary()
					_ = yym5
					if false {
					} else if z.HasExtensions() && z.EncExt(yy4) {
					} else {
						z.EncFallback(yy4)
					}
				} else {
					r.EncodeNil()
				}
			} else {
				if yyq2[0] {
					z.EncSendContainerState(codecSelfer_containerMapKey1234)
					r.EncodeString(codecSelferC_UTF81234, string("metadata"))
					z.EncSendContainerState(codecSelfer_containerMapValue1234)
					yy6 := &x.ObjectMeta
					yym7 := z.EncBinary()
					_ = yym7
					if false {
					} else if z.HasExtensions() && z.EncExt(yy6) {
					} else {
						z.EncFallback(yy6)
					}
				}
			}
			if yyr2 || yy2arr2 {
				z.EncSendContainerState(codecSelfer_containerArrayElem1234)
				if yyq2[1] {
					yy9 := &x.Status
					yy9.CodecEncodeSelf(e)
				} else {
					r.EncodeNil()
				}
			} else {
				if yyq2[1] {
					z.EncSendContainerState(codecSelfer_containerMapKey1234)
					r.EncodeString(codecSelferC_UTF81234, string("status"))
					z.EncSendContainerState(codecSelfer_containerMapValue1234)
					yy10 := &x.Status
					yy10.CodecEncodeSelf(e)
				}
			}
			if yyr2 || yy2arr2 {
				z.EncSendContainerState(codecSelfer_containerArrayElem1234)
				if yyq2[2] {
					yym12 := z.EncBinary()
					_ = yym12
					if false {
					} else {
						r.EncodeString(codecSelferC_UTF81234, string(x.Kind))
					}
				} else {
					r.EncodeString(codecSelferC_UTF81234, "")
				}
			} else {
				if yyq2[2] {
					z.EncSendContainerState(codecSelfer_containerMapKey1234)
					r.EncodeString(codecSelferC_UTF81234, string("kind"))
					z.EncSendContainerState(codecSelfer_containerMapValue1234)
					yym13 := z.EncBinary()
					_ = yym13
					if false {
					} else {
						r.EncodeString(codecSelferC_UTF81234, string(x.Kind))
					}
				}
			}
			if yyr2 || yy2arr2 {
				z.EncSendContainerState(codecSelfer_containerArrayElem1234)
				if yyq2[3] {
					yym15 := z.EncBinary()
					_ = yym15
					if false {
					} else {
						r.EncodeString(codecSelferC_UTF81234, string(x.APIVersion))
					}
				} else {
					r.EncodeString(codecSelferC_UTF81234, "")
				}
			} else {
				if yyq2[3] {
					z.EncSendContainerState(codecSelfer_containerMapKey1234)
					r.EncodeString(codecSelferC_UTF81234, string("apiVersion"))
					z.EncSendContainerState(codecSelfer_containerMapValue1234)
					yym16 := z.EncBinary()
					_ = yym16
					if false {
					} else {
						r.EncodeString(codecSelferC_UTF81234, string(x.APIVersion))
					}
				}
			}
			if yyr2 || yy2arr2 {
				z.EncSendContainerState(codecSelfer_containerArrayEnd1234)
			} else {
				z.EncSendContainerState(codecSelfer_containerMapEnd1234)
			}
		}
	}
}

func (x *TestType) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer1234
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	yym17 := z.DecBinary()
	_ = yym17
	if false {
	} else if z.HasExtensions() && z.DecExt(x) {
	} else {
		yyct18 := r.ContainerType()
		if yyct18 == codecSelferValueTypeMap1234 {
			yyl18 := r.ReadMapStart()
			if yyl18 == 0 {
				z.DecSendContainerState(codecSelfer_containerMapEnd1234)
			} else {
				x.codecDecodeSelfFromMap(yyl18, d)
			}
		} else if yyct18 == codecSelferValueTypeArray1234 {
			yyl18 := r.ReadArrayStart()
			if yyl18 == 0 {
				z.DecSendContainerState(codecSelfer_containerArrayEnd1234)
			} else {
				x.codecDecodeSelfFromArray(yyl18, d)
			}
		} else {
			panic(codecSelferOnlyMapOrArrayEncodeToStructErr1234)
		}
	}
}

func (x *TestType) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer1234
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yys19Slc = z.DecScratchBuffer() // default slice to decode into
	_ = yys19Slc
	var yyhl19 bool = l >= 0
	for yyj19 := 0; ; yyj19++ {
		if yyhl19 {
			if yyj19 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		z.DecSendContainerState(codecSelfer_containerMapKey1234)
		yys19Slc = r.DecodeBytes(yys19Slc, true, true)
		yys19 := string(yys19Slc)
		z.DecSendContainerState(codecSelfer_containerMapValue1234)
		switch yys19 {
		case "metadata":
			if r.TryDecodeAsNil() {
				x.ObjectMeta = pkg2_api.ObjectMeta{}
			} else {
				yyv20 := &x.ObjectMeta
				yym21 := z.DecBinary()
				_ = yym21
				if false {
				} else if z.HasExtensions() && z.DecExt(yyv20) {
				} else {
					z.DecFallback(yyv20, false)
				}
			}
		case "status":
			if r.TryDecodeAsNil() {
				x.Status = TestTypeStatus{}
			} else {
				yyv22 := &x.Status
				yyv22.CodecDecodeSelf(d)
			}
		case "kind":
			if r.TryDecodeAsNil() {
				x.Kind = ""
			} else {
				x.Kind = string(r.DecodeString())
			}
		case "apiVersion":
			if r.TryDecodeAsNil() {
				x.APIVersion = ""
			} else {
				x.APIVersion = string(r.DecodeString())
			}
		default:
			z.DecStructFieldNotFound(-1, yys19)
		} // end switch yys19
	} // end for yyj19
	z.DecSendContainerState(codecSelfer_containerMapEnd1234)
}

func (x *TestType) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer1234
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj25 int
	var yyb25 bool
	var yyhl25 bool = l >= 0
	yyj25++
	if yyhl25 {
		yyb25 = yyj25 > l
	} else {
		yyb25 = r.CheckBreak()
	}
	if yyb25 {
		z.DecSendContainerState(codecSelfer_containerArrayEnd1234)
		return
	}
	z.DecSendContainerState(codecSelfer_containerArrayElem1234)
	if r.TryDecodeAsNil() {
		x.ObjectMeta = pkg2_api.ObjectMeta{}
	} else {
		yyv26 := &x.ObjectMeta
		yym27 := z.DecBinary()
		_ = yym27
		if false {
		} else if z.HasExtensions() && z.DecExt(yyv26) {
		} else {
			z.DecFallback(yyv26, false)
		}
	}
	yyj25++
	if yyhl25 {
		yyb25 = yyj25 > l
	} else {
		yyb25 = r.CheckBreak()
	}
	if yyb25 {
		z.DecSendContainerState(codecSelfer_containerArrayEnd1234)
		return
	}
	z.DecSendContainerState(codecSelfer_containerArrayElem1234)
	if r.TryDecodeAsNil() {
		x.Status = TestTypeStatus{}
	} else {
		yyv28 := &x.Status
		yyv28.CodecDecodeSelf(d)
	}
	yyj25++
	if yyhl25 {
		yyb25 = yyj25 > l
	} else {
		yyb25 = r.CheckBreak()
	}
	if yyb25 {
		z.DecSendContainerState(codecSelfer_containerArrayEnd1234)
		return
	}
	z.DecSendContainerState(codecSelfer_containerArrayElem1234)
	if r.TryDecodeAsNil() {
		x.Kind = ""
	} else {
		x.Kind = string(r.DecodeString())
	}
	yyj25++
	if yyhl25 {
		yyb25 = yyj25 > l
	} else {
		yyb25 = r.CheckBreak()
	}
	if yyb25 {
		z.DecSendContainerState(codecSelfer_containerArrayEnd1234)
		return
	}
	z.DecSendContainerState(codecSelfer_containerArrayElem1234)
	if r.TryDecodeAsNil() {
		x.APIVersion = ""
	} else {
		x.APIVersion = string(r.DecodeString())
	}
	for {
		yyj25++
		if yyhl25 {
			yyb25 = yyj25 > l
		} else {
			yyb25 = r.CheckBreak()
		}
		if yyb25 {
			break
		}
		z.DecSendContainerState(codecSelfer_containerArrayElem1234)
		z.DecStructFieldNotFound(yyj25-1, "")
	}
	z.DecSendContainerState(codecSelfer_containerArrayEnd1234)
}

func (x *TestTypeList) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer1234
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yym31 := z.EncBinary()
		_ = yym31
		if false {
		} else if z.HasExtensions() && z.EncExt(x) {
		} else {
			yysep32 := !z.EncBinary()
			yy2arr32 := z.EncBasicHandle().StructToArray
			var yyq32 [4]bool
			_, _, _ = yysep32, yyq32, yy2arr32
			const yyr32 bool = false
			yyq32[0] = true
			yyq32[2] = x.Kind != ""
			yyq32[3] = x.APIVersion != ""
			var yynn32 int
			if yyr32 || yy2arr32 {
				r.EncodeArrayStart(4)
			} else {
				yynn32 = 1
				for _, b := range yyq32 {
					if b {
						yynn32++
					}
				}
				r.EncodeMapStart(yynn32)
				yynn32 = 0
			}
			if yyr32 || yy2arr32 {
				z.EncSendContainerState(codecSelfer_containerArrayElem1234)
				if yyq32[0] {
					yy34 := &x.ListMeta
					yym35 := z.EncBinary()
					_ = yym35
					if false {
					} else if z.HasExtensions() && z.EncExt(yy34) {
					} else {
						z.EncFallback(yy34)
					}
				} else {
					r.EncodeNil()
				}
			} else {
				if yyq32[0] {
					z.EncSendContainerState(codecSelfer_containerMapKey1234)
					r.EncodeString(codecSelferC_UTF81234, string("metadata"))
					z.EncSendContainerState(codecSelfer_containerMapValue1234)
					yy36 := &x.ListMeta
					yym37 := z.EncBinary()
					_ = yym37
					if false {
					} else if z.HasExtensions() && z.EncExt(yy36) {
					} else {
						z.EncFallback(yy36)
					}
				}
			}
			if yyr32 || yy2arr32 {
				z.EncSendContainerState(codecSelfer_containerArrayElem1234)
				if x.Items == nil {
					r.EncodeNil()
				} else {
					yym39 := z.EncBinary()
					_ = yym39
					if false {
					} else {
						h.encSliceTestType(([]TestType)(x.Items), e)
					}
				}
			} else {
				z.EncSendContainerState(codecSelfer_containerMapKey1234)
				r.EncodeString(codecSelferC_UTF81234, string("items"))
				z.EncSendContainerState(codecSelfer_containerMapValue1234)
				if x.Items == nil {
					r.EncodeNil()
				} else {
					yym40 := z.EncBinary()
					_ = yym40
					if false {
					} else {
						h.encSliceTestType(([]TestType)(x.Items), e)
					}
				}
			}
			if yyr32 || yy2arr32 {
				z.EncSendContainerState(codecSelfer_containerArrayElem1234)
				if yyq32[2] {
					yym42 := z.EncBinary()
					_ = yym42
					if false {
					} else {
						r.EncodeString(codecSelferC_UTF81234, string(x.Kind))
					}
				} else {
					r.EncodeString(codecSelferC_UTF81234, "")
				}
			} else {
				if yyq32[2] {
					z.EncSendContainerState(codecSelfer_containerMapKey1234)
					r.EncodeString(codecSelferC_UTF81234, string("kind"))
					z.EncSendContainerState(codecSelfer_containerMapValue1234)
					yym43 := z.EncBinary()
					_ = yym43
					if false {
					} else {
						r.EncodeString(codecSelferC_UTF81234, string(x.Kind))
					}
				}
			}
			if yyr32 || yy2arr32 {
				z.EncSendContainerState(codecSelfer_containerArrayElem1234)
				if yyq32[3] {
					yym45 := z.EncBinary()
					_ = yym45
					if false {
					} else {
						r.EncodeString(codecSelferC_UTF81234, string(x.APIVersion))
					}
				} else {
					r.EncodeString(codecSelferC_UTF81234, "")
				}
			} else {
				if yyq32[3] {
					z.EncSendContainerState(codecSelfer_containerMapKey1234)
					r.EncodeString(codecSelferC_UTF81234, string("apiVersion"))
					z.EncSendContainerState(codecSelfer_containerMapValue1234)
					yym46 := z.EncBinary()
					_ = yym46
					if false {
					} else {
						r.EncodeString(codecSelferC_UTF81234, string(x.APIVersion))
					}
				}
			}
			if yyr32 || yy2arr32 {
				z.EncSendContainerState(codecSelfer_containerArrayEnd1234)
			} else {
				z.EncSendContainerState(codecSelfer_containerMapEnd1234)
			}
		}
	}
}

func (x *TestTypeList) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer1234
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	yym47 := z.DecBinary()
	_ = yym47
	if false {
	} else if z.HasExtensions() && z.DecExt(x) {
	} else {
		yyct48 := r.ContainerType()
		if yyct48 == codecSelferValueTypeMap1234 {
			yyl48 := r.ReadMapStart()
			if yyl48 == 0 {
				z.DecSendContainerState(codecSelfer_containerMapEnd1234)
			} else {
				x.codecDecodeSelfFromMap(yyl48, d)
			}
		} else if yyct48 == codecSelferValueTypeArray1234 {
			yyl48 := r.ReadArrayStart()
			if yyl48 == 0 {
				z.DecSendContainerState(codecSelfer_containerArrayEnd1234)
			} else {
				x.codecDecodeSelfFromArray(yyl48, d)
			}
		} else {
			panic(codecSelferOnlyMapOrArrayEncodeToStructErr1234)
		}
	}
}

func (x *TestTypeList) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer1234
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yys49Slc = z.DecScratchBuffer() // default slice to decode into
	_ = yys49Slc
	var yyhl49 bool = l >= 0
	for yyj49 := 0; ; yyj49++ {
		if yyhl49 {
			if yyj49 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		z.DecSendContainerState(codecSelfer_containerMapKey1234)
		yys49Slc = r.DecodeBytes(yys49Slc, true, true)
		yys49 := string(yys49Slc)
		z.DecSendContainerState(codecSelfer_containerMapValue1234)
		switch yys49 {
		case "metadata":
			if r.TryDecodeAsNil() {
				x.ListMeta = pkg1_unversioned.ListMeta{}
			} else {
				yyv50 := &x.ListMeta
				yym51 := z.DecBinary()
				_ = yym51
				if false {
				} else if z.HasExtensions() && z.DecExt(yyv50) {
				} else {
					z.DecFallback(yyv50, false)
				}
			}
		case "items":
			if r.TryDecodeAsNil() {
				x.Items = nil
			} else {
				yyv52 := &x.Items
				yym53 := z.DecBinary()
				_ = yym53
				if false {
				} else {
					h.decSliceTestType((*[]TestType)(yyv52), d)
				}
			}
		case "kind":
			if r.TryDecodeAsNil() {
				x.Kind = ""
			} else {
				x.Kind = string(r.DecodeString())
			}
		case "apiVersion":
			if r.TryDecodeAsNil() {
				x.APIVersion = ""
			} else {
				x.APIVersion = string(r.DecodeString())
			}
		default:
			z.DecStructFieldNotFound(-1, yys49)
		} // end switch yys49
	} // end for yyj49
	z.DecSendContainerState(codecSelfer_containerMapEnd1234)
}

func (x *TestTypeList) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer1234
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj56 int
	var yyb56 bool
	var yyhl56 bool = l >= 0
	yyj56++
	if yyhl56 {
		yyb56 = yyj56 > l
	} else {
		yyb56 = r.CheckBreak()
	}
	if yyb56 {
		z.DecSendContainerState(codecSelfer_containerArrayEnd1234)
		return
	}
	z.DecSendContainerState(codecSelfer_containerArrayElem1234)
	if r.TryDecodeAsNil() {
		x.ListMeta = pkg1_unversioned.ListMeta{}
	} else {
		yyv57 := &x.ListMeta
		yym58 := z.DecBinary()
		_ = yym58
		if false {
		} else if z.HasExtensions() && z.DecExt(yyv57) {
		} else {
			z.DecFallback(yyv57, false)
		}
	}
	yyj56++
	if yyhl56 {
		yyb56 = yyj56 > l
	} else {
		yyb56 = r.CheckBreak()
	}
	if yyb56 {
		z.DecSendContainerState(codecSelfer_containerArrayEnd1234)
		return
	}
	z.DecSendContainerState(codecSelfer_containerArrayElem1234)
	if r.TryDecodeAsNil() {
		x.Items = nil
	} else {
		yyv59 := &x.Items
		yym60 := z.DecBinary()
		_ = yym60
		if false {
		} else {
			h.decSliceTestType((*[]TestType)(yyv59), d)
		}
	}
	yyj56++
	if yyhl56 {
		yyb56 = yyj56 > l
	} else {
		yyb56 = r.CheckBreak()
	}
	if yyb56 {
		z.DecSendContainerState(codecSelfer_containerArrayEnd1234)
		return
	}
	z.DecSendContainerState(codecSelfer_containerArrayElem1234)
	if r.TryDecodeAsNil() {
		x.Kind = ""
	} else {
		x.Kind = string(r.DecodeString())
	}
	yyj56++
	if yyhl56 {
		yyb56 = yyj56 > l
	} else {
		yyb56 = r.CheckBreak()
	}
	if yyb56 {
		z.DecSendContainerState(codecSelfer_containerArrayEnd1234)
		return
	}
	z.DecSendContainerState(codecSelfer_containerArrayElem1234)
	if r.TryDecodeAsNil() {
		x.APIVersion = ""
	} else {
		x.APIVersion = string(r.DecodeString())
	}
	for {
		yyj56++
		if yyhl56 {
			yyb56 = yyj56 > l
		} else {
			yyb56 = r.CheckBreak()
		}
		if yyb56 {
			break
		}
		z.DecSendContainerState(codecSelfer_containerArrayElem1234)
		z.DecStructFieldNotFound(yyj56-1, "")
	}
	z.DecSendContainerState(codecSelfer_containerArrayEnd1234)
}

func (x *TestTypeStatus) CodecEncodeSelf(e *codec1978.Encoder) {
	var h codecSelfer1234
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	if x == nil {
		r.EncodeNil()
	} else {
		yym63 := z.EncBinary()
		_ = yym63
		if false {
		} else if z.HasExtensions() && z.EncExt(x) {
		} else {
			yysep64 := !z.EncBinary()
			yy2arr64 := z.EncBasicHandle().StructToArray
			var yyq64 [1]bool
			_, _, _ = yysep64, yyq64, yy2arr64
			const yyr64 bool = false
			var yynn64 int
			if yyr64 || yy2arr64 {
				r.EncodeArrayStart(1)
			} else {
				yynn64 = 1
				for _, b := range yyq64 {
					if b {
						yynn64++
					}
				}
				r.EncodeMapStart(yynn64)
				yynn64 = 0
			}
			if yyr64 || yy2arr64 {
				z.EncSendContainerState(codecSelfer_containerArrayElem1234)
				yym66 := z.EncBinary()
				_ = yym66
				if false {
				} else {
					r.EncodeString(codecSelferC_UTF81234, string(x.Blah))
				}
			} else {
				z.EncSendContainerState(codecSelfer_containerMapKey1234)
				r.EncodeString(codecSelferC_UTF81234, string("Blah"))
				z.EncSendContainerState(codecSelfer_containerMapValue1234)
				yym67 := z.EncBinary()
				_ = yym67
				if false {
				} else {
					r.EncodeString(codecSelferC_UTF81234, string(x.Blah))
				}
			}
			if yyr64 || yy2arr64 {
				z.EncSendContainerState(codecSelfer_containerArrayEnd1234)
			} else {
				z.EncSendContainerState(codecSelfer_containerMapEnd1234)
			}
		}
	}
}

func (x *TestTypeStatus) CodecDecodeSelf(d *codec1978.Decoder) {
	var h codecSelfer1234
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	yym68 := z.DecBinary()
	_ = yym68
	if false {
	} else if z.HasExtensions() && z.DecExt(x) {
	} else {
		yyct69 := r.ContainerType()
		if yyct69 == codecSelferValueTypeMap1234 {
			yyl69 := r.ReadMapStart()
			if yyl69 == 0 {
				z.DecSendContainerState(codecSelfer_containerMapEnd1234)
			} else {
				x.codecDecodeSelfFromMap(yyl69, d)
			}
		} else if yyct69 == codecSelferValueTypeArray1234 {
			yyl69 := r.ReadArrayStart()
			if yyl69 == 0 {
				z.DecSendContainerState(codecSelfer_containerArrayEnd1234)
			} else {
				x.codecDecodeSelfFromArray(yyl69, d)
			}
		} else {
			panic(codecSelferOnlyMapOrArrayEncodeToStructErr1234)
		}
	}
}

func (x *TestTypeStatus) codecDecodeSelfFromMap(l int, d *codec1978.Decoder) {
	var h codecSelfer1234
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yys70Slc = z.DecScratchBuffer() // default slice to decode into
	_ = yys70Slc
	var yyhl70 bool = l >= 0
	for yyj70 := 0; ; yyj70++ {
		if yyhl70 {
			if yyj70 >= l {
				break
			}
		} else {
			if r.CheckBreak() {
				break
			}
		}
		z.DecSendContainerState(codecSelfer_containerMapKey1234)
		yys70Slc = r.DecodeBytes(yys70Slc, true, true)
		yys70 := string(yys70Slc)
		z.DecSendContainerState(codecSelfer_containerMapValue1234)
		switch yys70 {
		case "Blah":
			if r.TryDecodeAsNil() {
				x.Blah = ""
			} else {
				x.Blah = string(r.DecodeString())
			}
		default:
			z.DecStructFieldNotFound(-1, yys70)
		} // end switch yys70
	} // end for yyj70
	z.DecSendContainerState(codecSelfer_containerMapEnd1234)
}

func (x *TestTypeStatus) codecDecodeSelfFromArray(l int, d *codec1978.Decoder) {
	var h codecSelfer1234
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r
	var yyj72 int
	var yyb72 bool
	var yyhl72 bool = l >= 0
	yyj72++
	if yyhl72 {
		yyb72 = yyj72 > l
	} else {
		yyb72 = r.CheckBreak()
	}
	if yyb72 {
		z.DecSendContainerState(codecSelfer_containerArrayEnd1234)
		return
	}
	z.DecSendContainerState(codecSelfer_containerArrayElem1234)
	if r.TryDecodeAsNil() {
		x.Blah = ""
	} else {
		x.Blah = string(r.DecodeString())
	}
	for {
		yyj72++
		if yyhl72 {
			yyb72 = yyj72 > l
		} else {
			yyb72 = r.CheckBreak()
		}
		if yyb72 {
			break
		}
		z.DecSendContainerState(codecSelfer_containerArrayElem1234)
		z.DecStructFieldNotFound(yyj72-1, "")
	}
	z.DecSendContainerState(codecSelfer_containerArrayEnd1234)
}

func (x codecSelfer1234) encSliceTestType(v []TestType, e *codec1978.Encoder) {
	var h codecSelfer1234
	z, r := codec1978.GenHelperEncoder(e)
	_, _, _ = h, z, r
	r.EncodeArrayStart(len(v))
	for _, yyv74 := range v {
		z.EncSendContainerState(codecSelfer_containerArrayElem1234)
		yy75 := &yyv74
		yy75.CodecEncodeSelf(e)
	}
	z.EncSendContainerState(codecSelfer_containerArrayEnd1234)
}

func (x codecSelfer1234) decSliceTestType(v *[]TestType, d *codec1978.Decoder) {
	var h codecSelfer1234
	z, r := codec1978.GenHelperDecoder(d)
	_, _, _ = h, z, r

	yyv76 := *v
	yyh76, yyl76 := z.DecSliceHelperStart()
	var yyc76 bool
	if yyl76 == 0 {
		if yyv76 == nil {
			yyv76 = []TestType{}
			yyc76 = true
		} else if len(yyv76) != 0 {
			yyv76 = yyv76[:0]
			yyc76 = true
		}
	} else if yyl76 > 0 {
		var yyrr76, yyrl76 int
		var yyrt76 bool
		if yyl76 > cap(yyv76) {

			yyrg76 := len(yyv76) > 0
			yyv276 := yyv76
			yyrl76, yyrt76 = z.DecInferLen(yyl76, z.DecBasicHandle().MaxInitLen, 208)
			if yyrt76 {
				if yyrl76 <= cap(yyv76) {
					yyv76 = yyv76[:yyrl76]
				} else {
					yyv76 = make([]TestType, yyrl76)
				}
			} else {
				yyv76 = make([]TestType, yyrl76)
			}
			yyc76 = true
			yyrr76 = len(yyv76)
			if yyrg76 {
				copy(yyv76, yyv276)
			}
		} else if yyl76 != len(yyv76) {
			yyv76 = yyv76[:yyl76]
			yyc76 = true
		}
		yyj76 := 0
		for ; yyj76 < yyrr76; yyj76++ {
			yyh76.ElemContainerState(yyj76)
			if r.TryDecodeAsNil() {
				yyv76[yyj76] = TestType{}
			} else {
				yyv77 := &yyv76[yyj76]
				yyv77.CodecDecodeSelf(d)
			}

		}
		if yyrt76 {
			for ; yyj76 < yyl76; yyj76++ {
				yyv76 = append(yyv76, TestType{})
				yyh76.ElemContainerState(yyj76)
				if r.TryDecodeAsNil() {
					yyv76[yyj76] = TestType{}
				} else {
					yyv78 := &yyv76[yyj76]
					yyv78.CodecDecodeSelf(d)
				}

			}
		}

	} else {
		yyj76 := 0
		for ; !r.CheckBreak(); yyj76++ {

			if yyj76 >= len(yyv76) {
				yyv76 = append(yyv76, TestType{}) // var yyz76 TestType
				yyc76 = true
			}
			yyh76.ElemContainerState(yyj76)
			if yyj76 < len(yyv76) {
				if r.TryDecodeAsNil() {
					yyv76[yyj76] = TestType{}
				} else {
					yyv79 := &yyv76[yyj76]
					yyv79.CodecDecodeSelf(d)
				}

			} else {
				z.DecSwallow()
			}

		}
		if yyj76 < len(yyv76) {
			yyv76 = yyv76[:yyj76]
			yyc76 = true
		} else if yyj76 == 0 && yyv76 == nil {
			yyv76 = []TestType{}
			yyc76 = true
		}
	}
	yyh76.End()
	if yyc76 {
		*v = yyv76
	}
}
